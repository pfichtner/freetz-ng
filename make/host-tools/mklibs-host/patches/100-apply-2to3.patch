--- a/src/mklibs
+++ b/src/mklibs
@@ -57,7 +57,7 @@
 
 def debug(level, *msg):
     if debuglevel >= level:
-        print(string.join(msg))
+        print((string.join(msg)))
 
 # return a list of lines of output of the command
 def command(command, *args):
@@ -66,9 +66,9 @@
     output = pipe.read().strip()
     status = pipe.close() 
     if status is not None and os.WEXITSTATUS(status) != 0:
-        print("Command failed with status", os.WEXITSTATUS(status),  ":", \
-               command, string.join(args))
-        print("With output:", output)
+        print(("Command failed with status", os.WEXITSTATUS(status),  ":", \
+               command, string.join(args)))
+        print(("With output:", output))
         sys.exit(1)
     return [i for i in output.split('\n') if i]
 
@@ -313,7 +313,7 @@
     sys.exit(was_err)
 
 def version(vers):
-    print("mklibs: version ",vers)
+    print(("mklibs: version ",vers))
     print("")
 
 #################### main ####################
@@ -403,7 +403,7 @@
         version(vers)
         sys.exit(0)
     else:
-        print("WARNING: unknown option: " + opt + "\targ: " + arg)
+        print(("WARNING: unknown option: " + opt + "\targ: " + arg))
 
 if include_default_lib_path == "yes":
     lib_path.extend([a.replace("/lib/", "/" + libdir + "/") for a in default_lib_path])
@@ -421,7 +421,7 @@
 objects = {}  # map from inode to filename
 for prog in proglist:
     inode = os.stat(prog)[ST_INO]
-    if objects.has_key(inode):
+    if inode in objects:
         debug(DEBUG_SPAM, prog, "is a hardlink to", objects[inode])
     elif so_pattern.match(prog):
         debug(DEBUG_SPAM, prog, "is a library")
@@ -431,7 +431,7 @@
         objects[inode] = prog
 
 if not ldlib:
-    for obj in objects.values():
+    for obj in list(objects.values()):
         output = command("mklibs-readelf", "--print-interp", obj)
         if output:
             ldlib = output.pop()
@@ -451,10 +451,10 @@
             for rpath_elem in rpath_val:
                 if not rpath_elem in lib_rpath:
                     if debuglevel >= DEBUG_VERBOSE:
-                        print("Adding rpath " + rpath_elem + " for " + obj)
+                        print(("Adding rpath " + rpath_elem + " for " + obj))
                     lib_rpath.append(rpath_elem)
         else:
-            print("warning: " + obj + " may need rpath, but --root not specified")
+            print(("warning: " + obj + " may need rpath, but --root not specified"))
 
 lib_path.extend(lib_rpath)
 
@@ -464,9 +464,9 @@
 while 1:
     debug(DEBUG_NORMAL, "I: library reduction pass", str(passnr))
     if debuglevel >= DEBUG_VERBOSE:
-        print("Objects:",)
-        for obj in sorted([x[string.rfind(x, '/') + 1:] for x in objects.values()]):
-            print(obj,)
+        print(("Objects:",))
+        for obj in sorted([x[string.rfind(x, '/') + 1:] for x in list(objects.values())]):
+            print((obj,))
         print()
 
     passnr = passnr + 1
@@ -476,7 +476,7 @@
         obj = dest_path + "/" + lib
         small_libs.append(obj)
         inode = os.stat(obj)[ST_INO]
-        if objects.has_key(inode):
+        if inode in objects:
             debug(DEBUG_SPAM, obj, "is hardlink to", objects[inode])
         else:
             objects[inode] = obj
--- a/src/mklibs-copy
+++ b/src/mklibs-copy
@@ -51,9 +51,9 @@
     output = pipe.read().strip()
     status = pipe.close()
     if status is not None and os.WEXITSTATUS(status) != 0:
-        print("Command failed with status", os.WEXITSTATUS(status),  ":", \
-               command, ' '.join(args))
-        print("With output:", output)
+        print(("Command failed with status", os.WEXITSTATUS(status),  ":", \
+               command, ' '.join(args)))
+        print(("With output:", output))
         sys.exit(1)
     return output.split('\n')
 
@@ -134,7 +134,7 @@
         return paths
 
 def version(vers):
-    print("mklibs: version ",vers)
+    print(("mklibs: version ",vers))
     print("")
 
 # Clean the environment
@@ -159,7 +159,7 @@
 objects = {}  # map from inode to filename
 for prog in proglist:
     inode = os.stat(prog)[ST_INO]
-    if objects.has_key(inode):
+    if inode in objects:
         logger.debug("%s is a hardlink to %s", prog, objects[inode])
     elif so_pattern.match(prog):
         logger.debug("%s is a library", prog)
@@ -169,7 +169,7 @@
         logger.debug("%s is no ELF", prog)
 
 if not ldlib:
-    for obj in objects.values():
+    for obj in list(objects.values()):
         output = command("mklibs-readelf", "-i", obj)
         for x in output:
                 ldlib = x
@@ -182,7 +182,7 @@
 logger.info('Using %s as dynamic linker', ldlib)
 
 # Check for rpaths
-for obj in objects.values():
+for obj in list(objects.values()):
     rpath_val = rpath(obj)
     if rpath_val:
         if root:
@@ -208,18 +208,18 @@
         obj = dest_path + "/" + lib
         small_libs.append(obj)
         inode = os.stat(obj)[ST_INO]
-        if objects.has_key(inode):
+        if inode in objects:
             logger.debug("%s is hardlink to %s", obj, objects[inode])
         else:
             objects[inode] = obj
 
-    for obj in objects.values():
+    for obj in list(objects.values()):
         small_libs.append(obj)
 
-    logger.verbose('Objects: %r', ' '.join([i[i.rfind('/') + 1:] for i in objects.itervalues()]))
+    logger.verbose('Objects: %r', ' '.join([i[i.rfind('/') + 1:] for i in objects.values()]))
 
     libraries = set()
-    for obj in objects.values():
+    for obj in list(objects.values()):
         libraries.update(library_depends(obj))
 
     if libraries == previous_pass_libraries:
